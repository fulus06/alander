开发一个像 Blender 这样的全能 3D 创作套件（DCC, Digital Content Creation）是一个巨大的工程。为了避免陷入“造轮子”的泥潭而无法产出，必须采用**敏捷开发（Agile）**和**最小可行性产品（MVP）**的策略。

这份路线图将开发周期分为 **5 个阶段**，从底层的图形架构到最终的云端协作。

---

### 第一阶段：基石构建 (Foundation & Core)
**目标**：构建一个能跑在桌面和浏览器上的高性能 3D 查看器。
**耗时预估**：2 - 3 个月

#### 1.1 项目脚手架与窗口化
*   **任务**: 建立 Rust 工作区，集成核心库。
*   **技术栈**:
    *   `winit`: 跨平台窗口管理。
    *   `wgpu`: 渲染后端（Vulkan/Metal/DX12/WebGL）。
    *   `log` / `tracing`: 日志系统（一开始就要做，方便调试）。
*   **产出**: 一个能打开的黑色窗口，按 ESC 能退出。

#### 1.2 ECS 数据架构
*   **任务**: 定义场景的数据结构。DCC 软件不同于游戏，需要频繁增删改查。
*   **设计**:
    *   引入 `bevy_ecs` 或 `hecs`。
    *   定义核心 Component: `Transform` (位置/旋转/缩放), `Mesh` (网格数据 handle), `Material` (材质数据 handle), `Name` (物体名称).
*   **产出**: 在代码中创建一个 Entity，打印它的 ID。

#### 1.3 渲染管线原型 (The Renderer)
*   **任务**: 让物体显示出来。
*   **工作**:
    *   编写基础 WGSL Shader（顶点着色器 + 片元着色器）。
    *   实现 Camera 系统（透视投影 + 视图矩阵）。
    *   实现基础的 Orbit Controller（鼠标拖拽旋转视图）。
*   **产出**: 屏幕中间显示一个彩色的三角形/立方体，鼠标可以 360 度旋转观察它。

#### 1.4 资产导入 (The Importer)
*   **任务**: 不写私有格式，拥抱标准。
*   **技术栈**: `gltf` crate。
*   **产出**: 能加载标准的 `.gltf` / `.glb` 模型（如著名的 Sponza 场景或简单角色）。

---

### 第二阶段：交互与编辑器框架 (Interaction & Editor)
**目标**：从“查看器”变成“编辑器”。
**耗时预估**：3 - 4 个月

#### 2.1 UI 集成
*   **任务**: 搭建编辑器的操作界面。
*   **技术栈**: `egui` + `egui_dock` (实现类似 Blender 的可拖拽面板)。
*   **功能**:
    *   **Outliner (大纲视图)**: 列出场景中所有 Entity。
    *   **Properties (属性面板)**: 选中物体后显示其坐标、材质参数。
*   **产出**: 点击大纲里的名字，属性面板随之更新。

#### 2.2 拾取与 Gizmo (核心交互)
*   **任务**: 在 3D 空间中选中并操作物体。
*   **难点**: 鼠标点击屏幕（2D）到 3D 空间的射线检测（Ray Casting）。
*   **技术栈**: `transform-gizmo` (Rust 社区已有现成轮子，先集成)。
*   **产出**: 点击 3D 物体变色（选中），出现三轴手柄，拖动轴可以移动物体位置。

#### 2.3 撤销/重做系统 (Undo/Redo)
*   **任务**: 编辑器的后悔药。这是区分“游戏”和“工具”的关键。
*   **设计**: 命令模式 (Command Pattern)。记录每次操作的逆操作。
*   **产出**: 移动物体后，按 `Ctrl+Z` 物体回到原位。

---

### 第三阶段：节点系统与程序化生成 (The "Alander" Magic)
**目标**：实现差异化，对标 Houdini/Blender Geometry Nodes。
**耗时预估**：4 - 5 个月

#### 3.1 节点图编辑器
*   **任务**: 可视化编程界面。
*   **技术栈**: `egui_node_graph`。
*   **产出**: 一个可以连线的面板，拥有 Input Node, Math Node, Output Node。

#### 3.2 数据流驱动 (Data Flow)
*   **任务**: 让节点图真正控制场景。
*   **实现**: 将 Mesh 数据不再存为静态，而是视为流过 Pipeline 的数据。
*   **案例**:
    *   `Cube Node` -> `Transform Node (Scale * 2)` -> `Output`.
*   **产出**: 拖动节点图里的数值，场景里的模型实时变形。

#### 3.3 材质节点 (Shader Graph)
*   **任务**: 可视化编辑材质。
*   **实现**: 将节点图编译为 WGSL 代码（即时编译）。
*   **产出**: 通过连线混合颜色和纹理，实时在模型上看到效果。

---

### 第四阶段：动画与物理 (Animation & Physics)
**目标**：让场景动起来。
**耗时预估**：3 - 4 个月

#### 4.1 物理集成
*   **任务**: 集成物理引擎。
*   **技术栈**: `rapier3d` (官方支持 Rust，性能极强)。
*   **产出**: 给立方体添加 `RigidBody` 组件，点击播放，立方体受重力掉落并与地面碰撞。

#### 4.2 时间轴与关键帧
*   **任务**: 记录时间变化。
*   **实现**: 定义 `AnimationCurve` 结构体，实现插值算法（Lerp, Slerp）。
*   **产出**: 在第 0 帧和第 60 帧打关键帧，中间自动补间动画。

---

### 第五阶段：Web 协作与云端化 (The Killer Feature)
**目标**：实现“多人实时协作”，这是 Alander 战胜 Blender 的杀手锏。
**耗时预估**：3 个月 + 持续优化

#### 5.1 WebAssembly (Wasm) 移植
*   **任务**: 将 Rust 代码编译为 Wasm。
*   **技术栈**: `wasm-bindgen`, `wasm-pack`。
*   **产出**: 在 Chrome 浏览器中直接打开 Alander，无需下载安装包。

#### 5.2 网络同步架构
*   **任务**: 多人状态同步。
*   **技术栈**:
    *   `matchbox_socket` (WebRTC P2P 连接)。
    *   **CRDT (Conflict-free Replicated Data Types)**: 使用 `yjs` 的 Rust 绑定或 `automerge`，解决多人同时修改同一个物体时的冲突。
*   **产出**: A 用户在浏览器里移动物体，B 用户在桌面客户端看到物体同时移动。

---

### 路线图总结与里程碑

| 阶段   | 时间周期 | 核心里程碑 (Milestone)                                | 类似于                    |
| :----- | :------- | :---------------------------------------------------- | :------------------------ |
| **P1** | 0-3 月   | **The Viewer**: 能加载 glTF，能摄像机漫游。           | Sketchfab                 |
| **P2** | 3-6 月   | **The Layout Tool**: 能摆放物体，修改属性，撤销重做。 | Unity Editor (Scene view) |
| **P3** | 6-10 月  | **The Node Engine**: 能通过节点生成模型和材质。       | Houdini Lite              |
| **P4** | 10-14 月 | **The Animator**: 物理模拟与简单动画回放。            | Blender (Physics tab)     |
| **P5** | 14-17 月 | **The Platform**: 网页版上线，支持多人协作。          | Figma                     |

### 给开发者的关键建议 (避坑指南)

1.  **不要一开始就写半边结构 (Half-Edge) 的网格编辑器**：
    *   *原因*：实现点/线/面的拓扑修改极其复杂且枯燥，容易劝退。
    *   *策略*：早期只做“物体级别”的编辑（移动整个桌子，而不是移动桌腿的一个点）。
2.  **数据层与渲染层分离**：
    *   确保你的 ECS 数据是纯数据的，不包含 GPU 资源。渲染系统应该每一帧去读取数据并绘制。这样方便以后做“无头模式（Headless）”的云端渲染服务。
3.  **UI 丑一点没关系**：
    *   初期不要在 UI 美化上花时间，功能逻辑跑通最重要。`egui` 的默认样式足够开发用了。

祝你的 Alander 项目起飞！这会是一段非常硬核但充满成就感的 Rust 之旅。